//*************************** модуль для работы с дата флэш AT45DB321D*******************//
#include "stm32f10x.h"
#include "pin.h"
#include "FLASH_AT45DB.h"
#include <string.h>


#define FLASH_READY	      0x80
#define FLASH_NOT_READY	  0x00

#define GO_IDLE_STATE            0              //??????????? ????????????   
#define SEND_IF_COND             8              //??? SDC V2 - ???????? ????????? ??????????   
#define READ_SINGLE_BLOCK        17             //?????? ?????????? ????? ??????  
#define WRITE_SINGLE_BLOCK       24             //?????? ?????????? ????? ??????
#define SD_SEND_OP_COND	         41             //?????? ???????? ?????????????  
#define APP_CMD			 55             //??????? ??????? ?? ACMD <n> ??????
#define READ_OCR		 58             //?????? ???????? OCR
#define AT45DB_WAIT_READY() {while (AT45DB_READ_STATUS()!=FLASH_READY);}

#define CS_ENABLE         GPIOA->BSRR = GPIO_BSRR_BR4;         
#define CS_DISABLE    	  GPIOA->BSRR = GPIO_BSRR_BS4; 

typedef struct
 {
  unsigned char Manufacturer_ID;   	//код производителя (ATMEL = 0x1F)
  unsigned char DeviceID_1;	   		//семейство
  unsigned char DeviceID_2;   		//версия продукта
 } TDataFlsh;

TDataFlsh DataFlash_ID;
uint8_t  SDHC; 
unsigned char temp[AT45DB_PAGE_SIZE];	

//-------------------------------------------------------------------//
//Настройка SPI
//-------------------------------------------------------------------//
void SPI_SETUP(void)
{
  RCC->APB2ENR |=  RCC_APB2ENR_AFIOEN;//???????? ???????????? ?????????????? ???????
  RCC->APB2ENR |=  RCC_APB2ENR_IOPAEN;//???????? ???????????? ????? ?
	//RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE);
 
  //????? ?????????? SS: ????? ???????????, ?????? ??????????,50MHz
  GPIOA->CRL   |=  GPIO_CRL_MODE4;    //
  GPIOA->CRL   &= ~GPIO_CRL_CNF4;     //
  GPIOA->BSRR   =  GPIO_BSRR_BS4;     //
 
  //????? SCK: ????? ???????????, ?????????????? ???????, 50MHz
  GPIOA->CRL   |=  GPIO_CRL_MODE5;    //
  GPIOA->CRL   &= ~GPIO_CRL_CNF5;     //
  GPIOA->CRL   |=  GPIO_CRL_CNF5_1;   //
 
  //????? MISO: ???? ???????? ? ????????????? ??????????, ???????? ? ?????
  GPIOA->CRL   &= ~GPIO_CRL_MODE6;    //
  GPIOA->CRL   &= ~GPIO_CRL_CNF6;     //
  GPIOA->CRL   |=  GPIO_CRL_CNF6_1;   //
  GPIOA->BSRR   =  GPIO_BSRR_BS6;     //
 
  //????? MOSI: ????? ???????????, ?????????????? ???????, 50MHz
  GPIOA->CRL   |=  GPIO_CRL_MODE7;    //
  GPIOA->CRL   &= ~GPIO_CRL_CNF7;     //
  GPIOA->CRL   |=  GPIO_CRL_CNF7_1;   //



	RCC->APB2ENR |= RCC_APB2ENR_SPI1EN;
	SPI1->CR2     = 0x0000;
	SPI1->CR1     = SPI_CR1_MSTR;       //?????????? ?????? ???? ????????,???????
  //SPI1->CR1    |= SPI_CR1_BR;         //??? ?????? ??????? ????????? ????????
	SPI1->CR1    |= SPI_CR1_BR_1;
  SPI1->CR1    |= SPI_CR1_SSI;
  SPI1->CR1    |= SPI_CR1_SSM;
	SPI1->CR1    |= SPI_CR1_SPE; 
}



u8 SPI_SendByte(u8 byte)
{
	  while (!(SPI1->SR & SPI_SR_TXE));      //?????????, ??? ?????????? ???????? ?????????
  SPI1->DR = byte;                       //????????? ?????? ??? ????????
  while (!(SPI1->SR & SPI_SR_RXNE));     //???? ????????? ??????
  return (SPI1->DR);		         //?????? ???????? ??????
}
/*uint8_t spi_send (uint8_t data)
{
  while (!(SPI1->SR & SPI_SR_TXE));      //?????????, ??? ?????????? ???????? ?????????
  SPI1->DR = data;                       //????????? ?????? ??? ????????
  while (!(SPI1->SR & SPI_SR_RXNE));     //???? ????????? ??????
  return (SPI1->DR);		         //?????? ???????? ??????
}*/

/*uint8_t spi_send (uint8_t data)
{
  while (!(SPI1->SR & SPI_SR_TXE));      //?????????, ??? ?????????? ???????? ?????????
  SPI1->DR = data;                       //????????? ?????? ??? ????????
  while (!(SPI1->SR & SPI_SR_RXNE));     //???? ????????? ??????
  return (SPI1->DR);		         //?????? ???????? ??????
}*/
/*
uint8_t SPI_ReadByte (void)
{
  return SPI_SendByte(0xff);		  //?????? ???????? ??????
}
*/

uint8_t SD_sendCommand(uint8_t cmd, uint32_t arg)
{
  uint8_t response, wait=0, tmp;     
 
  //??? ???? ?????? SD ????????? ???????? ??????, ?.?. ??? ??? ????????? ????????? 
  if(SDHC == 0)		
  if(cmd == READ_SINGLE_BLOCK || cmd == WRITE_SINGLE_BLOCK )  {arg = arg << 9;}
  //??? SDHC ???????? ?????? ????? ????????? ?? ?????(???????????? ?????????)	
 
  CS_ENABLE;
 
  //???????? ??? ??????? ? ?? ????????
  SPI_SendByte(cmd | 0x40);
  SPI_SendByte(arg>>24);
  SPI_SendByte(arg>>16);
  SPI_SendByte(arg>>8);
  SPI_SendByte(arg);
 
  //???????? CRC (????????? ?????? ??? ???? ??????)
  if(cmd == SEND_IF_COND) SPI_SendByte(0x87);            
  else                    SPI_SendByte(0x95); 
 
  //??????? ?????
  while((response = SPI_SendByte(0xFF)) == 0xff) 
   if(wait++ > 0xfe) break;                //???????, ?? ???????? ????? ?? ???????
 
  //???????? ?????? ???? ?????????? ??????? READ_OCR
  if(response == 0x00 && cmd == 58)     
  {
    tmp = SPI_SendByte(0xFF);                      //???????? ???? ???? ???????? OCR            
    if(tmp & 0x40) SDHC = 1;               //?????????? ????? SDHC 
    else           SDHC = 0;               //?????????? ????? SD
    //????????? ??? ?????????? ????? ???????? OCR
    SPI_SendByte(0xFF); 
    SPI_SendByte(0xFF); 
    SPI_SendByte(0xFF); 
  }
 
  SPI_SendByte(0xFF);
 
  CS_DISABLE; 
 
  return response;
}
//-------------------------------------------------------------------//
//DataFlash@AT45DB321
//-------------------------------------------------------------------//

unsigned char AT45DB_INIT(void)
{
  uint8_t   i;
  uint8_t   response;
  uint8_t   SD_version = 2;	          //?? ????????? ?????? SD = 2
  uint16_t  retry = 0 ;
 
  SPI_SETUP();                            //???????????????? ?????? SPI  
CS_DISABLE;	
  for(i=0;i<10;i++) SPI_SendByte(0xFF);      //??????? ????? 74 ??????   
 
  //???????? ??????????? ????? ?????
  CS_ENABLE;
  while(SD_sendCommand(GO_IDLE_STATE, 0)!=0x01)                                   
    if(retry++>0x20)  return 2;                    
  CS_DISABLE;
  SPI_SendByte (0xff);
  SPI_SendByte (0xff);
 
  retry = 0;                                     
  while(SD_sendCommand(SEND_IF_COND,0x000001AA)!=0x01)
  { 
    if(retry++>0xfe) 
    { 
      SD_version = 1;
      break;
    } 
  }
 
 retry = 0;                                     
 do
 {
   response = SD_sendCommand(APP_CMD,0); 
   response = SD_sendCommand(SD_SEND_OP_COND,0x40000000);
   retry++;
   if(retry>0xffe) return 1;                     
 }while(response != 0x00);                      
 
 
 //?????? ??????? OCR, ????? ?????????? ??? ?????
 retry = 0;
 SDHC = 0;
 if (SD_version == 2)
 { 
   while(SD_sendCommand(READ_OCR,0)!=0x00)
	 if(retry++>0xfe)  break;
 }
 
 return 0; 
}

unsigned char AT45DB_READ_STATUS(void)
{
 unsigned char status; 

  pin_SPI_CS(LOW);

  SPI_SendByte(_STATUS_READ); 
  status = SPI_SendByte(0xFF);

  pin_SPI_CS(HIGTH);
	
  return (status&0x80);
}


void AT45DB_SEND_OPCODE(unsigned char opcode, unsigned short page, unsigned short adr)
{
//unsigned int temp;

//temp = page;
  page&=AT45DB_CHIP_MASK;
  adr&=AT45DB_PAGE_MASK;

  SPI_SendByte(opcode); 

#ifdef AT45DB321D

  /*if (page==0) 
   {
    page=temp;
   } */

  SPI_SendByte(page>>6);
  SPI_SendByte(page<<2|adr>>8);
  SPI_SendByte(adr); 

#endif

   
}

void AT45DB_CHIP_ERASE(void)
{
  AT45DB_WAIT_READY();
  
  pin_SPI_CS(LOW);

  SPI_SendByte(_CHIP_ERASE1);
  SPI_SendByte(_CHIP_ERASE2);
  SPI_SendByte(_CHIP_ERASE3);
  SPI_SendByte(_CHIP_ERASE4);
   
  pin_SPI_CS(HIGTH); 
}

void AT45DB_PAGE_ERASE(unsigned int adr_page)
{
  AT45DB_WAIT_READY();
  
  pin_SPI_CS(LOW);

  AT45DB_SEND_OPCODE(_PAGE_ERASE,adr_page,0);
   
  pin_SPI_CS(HIGTH); 
}

void AT45DB_PAGE_SET(unsigned int adr_page, unsigned char set_data)
{
  unsigned short i = AT45DB_PAGE_SIZE;

  AT45DB_WAIT_READY();

  pin_SPI_CS(LOW);

  AT45DB_SEND_OPCODE(_MEM_PROGRAM_THROUGH_BUF1, adr_page, 0);

  while (i--) 
		SPI_SendByte(set_data);

  pin_SPI_CS(HIGTH); 

}

void AT45DB_CHIP_SET(unsigned char set_data)
{
  unsigned short i = AT45DB_PAGE_COUNT;

  AT45DB_WAIT_READY();

  while (i--) 
	AT45DB_PAGE_SET(i,set_data);

  

}


void AT45DB_WRITE_PAGE(unsigned int BlockNumb, const unsigned char  * buff)
{
  uint8_t     response;
  uint16_t    i,wait=0;
 
  //??????? ??????? "?????? ?????? ?????" ? ????????? ??? ??????
  if( SD_sendCommand(WRITE_SINGLE_BLOCK, BlockNumb)) return;
 
  CS_ENABLE;
  SPI_SendByte(0xfe);    
 
  //???????? ????? ??????? ? ?????
  for(i=0; i<512; i++) SPI_SendByte(*buff++);
 
  SPI_SendByte(0xff);                //?????? 2 ????? CRC ??? ??? ????????
  SPI_SendByte(0xff);
 
  response = SPI_SendByte(0xFF);
 
  if( (response & 0x1f) != 0x05) //???? ?????? ??? ?????? ?????? ??????
  { CS_DISABLE; return; }
 
  //??????? ????????? ?????? ????? ??????
  while(!SPI_SendByte(0xFF))             //???? ????? ??????,??? ?????? ????
  if(wait++ > 0xfffe){CS_DISABLE; return;}
 
  CS_DISABLE;
  SPI_SendByte(0xff);   
  CS_ENABLE;         
 
  while(!SPI_SendByte(0xFF))               //???? ????? ??????,??? ?????? ????
  if(wait++ > 0xfffe){CS_DISABLE; return;}
  CS_DISABLE;
 
  return;
}

void AT45DB_READ_PAGE(unsigned int BlockNumb, unsigned char *buff)
{
  uint16_t i=0;
 
  //??????? ??????? "?????? ?????? ?????" ? ????????? ??? ??????
  if(SD_sendCommand(READ_SINGLE_BLOCK, BlockNumb)) return;  
  CS_ENABLE;
  //????????  ??????? ??????
  while(SPI_SendByte(0xFF) != 0xfe)                
  if(i++ > 0xfffe) {CS_DISABLE; return;}       
 
  //?????? 512 ????	?????????? ???????
  for(i=0; i<512; i++) *buff++ = SPI_SendByte(0xFF);
 
  SPI_SendByte(0xFF); 
  SPI_SendByte(0xFF); 
  SPI_SendByte(0xFF); 
 
  CS_DISABLE;
 
  return;
	
}

void AT45DB_READ_DATA(unsigned int adr_page, unsigned short offset, unsigned char *buf, unsigned short size)
{
 

 //копируем страницу в буфер
 AT45DB_READ_PAGE(adr_page, &temp[0]);

 if ((offset+size)<=AT45DB_PAGE_SIZE)
  memcpy(buf, &temp[offset], size);


}

void AT45DB_WRITE_DATA(unsigned int adr_page, unsigned short offset, unsigned char *buf, unsigned short size)
{
 

 //копируем страницу в буфер
 AT45DB_READ_PAGE(adr_page, &temp[0]);

 if ((offset+size)<=AT45DB_PAGE_SIZE)
  memcpy(&temp[offset],buf, size);

 AT45DB_WRITE_PAGE(adr_page,&temp[0]); 


}


//#include <MainHard.h>
/*
pdata unsigned char DEL;

#define SET_CC  SETCC()
#define RES_CC  RESCC()


void SETCC()
{
 DEL=DEL++;SetCSFL;
}

void RESCC()
{
 DEL=DEL++;ResCSFL;
}

void SPI_Init (void)
{
 	SPI0CFG|=0xC7;
 	//SPI0CKR=0x1F;   //clk /2
	SPI0CKR=0x20;   //clk /2
    //SPI0CKR=0x1E;   //clk /2
 	SPI0CN = 0x02;	// SPI Control Register
 	SPI0CN |= 0x01;
}


unsigned char SPITransfer(unsigned char byte)
{
//unsigned char T;
   // T = SPI0CN;
 	SPI0DAT=byte;
 	while (!SPIF);
 	SPIF=0;
	//if (byte==0x13) return T;
 	return SPI0DAT;
}


bit FlashReadStatus()
{
 unsigned char status; 
 	RES_CC; 
	status=SPITransfer(0x57);
	status=SPITransfer(0xFF);
	SET_CC;
 	return ((status&0xBC)==0xAC);
}

#define WaitRady {while (!FlashReadStatus());}

bit FLASH_INIT()
{
 unsigned char S;
	RES_CC;
 	SPITransfer(0xD7);
 	S=SPITransfer(0xFF);
 	SET_CC;
 	return ((S&0x3C)!=0x2C);//если флэш неисправна то вернуть 1 
}

void SendHand(unsigned char code_fun, unsigned int page,adr)
{
   	SPITransfer(code_fun);
   	SPITransfer(page>>6);
   	SPITransfer(page<<2|adr>>8);
   	SPITransfer(adr);
}




void WriteFlash(unsigned long addr, void *source, unsigned char count)
{
 unsigned A;
 unsigned PGaddr;

 	 A=addr&511;      
 	 PGaddr=addr>>9;
	 
 	 WaitRady;		  

    RES_CC;
	 SendHand(0x53,PGaddr,0xFF);
	SET_CC;

	WaitRady;

 if ((A+count)<=512)
   {
    RES_CC;
     SendHand(0x82,PGaddr,A);
     while (count--) SPITransfer(*((char *)source)++);
	SET_CC;
   }
 else 
   {
    RES_CC;
     SendHand(0x82,PGaddr,A);
     A=512-A;
     count-=A;
	 while (A--) SPITransfer(*((char *)source)++);
    SET_CC;

    WaitRady;
    PGaddr++;

    RES_CC;
	 SendHand(0x53,PGaddr,0xFF);
	SET_CC;

    WaitRady;

	RES_CC;
     SendHand(0x82,PGaddr,0);
     while (count--) SPITransfer(*((char *)source)++);
    SET_CC;
   }

}


void ReadFlash(unsigned long addr, void *destination, unsigned char count)
{
 unsigned A;
 unsigned PGaddr;
 
 A=addr&511;       //смещение внутри страницы
 PGaddr=addr>>9;   //адрес страницы
 WaitRady;         //while (!FlashReadStatus());

 if ((A+count)<=512) 
   {
    RES_CC;
	SendHand(0xD2,PGaddr,A);
	SPITransfer(0xFF);
    SPITransfer(0xFF);
    SPITransfer(0xFF);
    SPITransfer(0xFF);
    while (count--) *((unsigned char *)destination)++=SPITransfer(0xFF);
    SET_CC;
   }
 else
   {
    RES_CC;
	SendHand(0xD2,PGaddr,A);
	SPITransfer(0xFF);
    SPITransfer(0xFF);
    SPITransfer(0xFF);
    SPITransfer(0xFF);
    A=512-A;
    count=count-A;
    while (A--) *((unsigned char *)destination)++=SPITransfer(0xFF);
    SET_CC;
    WaitRady;
    RES_CC;
    PGaddr++;
	SendHand(0xD2,PGaddr,0);
    SPITransfer(0xFF);
    SPITransfer(0xFF);
    SPITransfer(0xFF);
    SPITransfer(0xFF);
    while (count--) *((unsigned char *)destination)++=SPITransfer(0xFF);
    SET_CC;
   }
 
}





void SPIWriteBuf (unsigned long addr, unsigned char *source, unsigned char count)
{
 void *P;
 P = &addr;
 *(unsigned char *)P = 0x84;
 WaitRady;

 ResCSFL;
  SendHand(P);
  while (count--) SPITransfer(*source++);
 SetCSFL;
}


void SPIBufRead(unsigned long addr, unsigned char *destination, unsigned char count)
{
void *P;
 P = &addr;
 *(unsigned char *)P = 0xD1;
 WaitRady;

 ResCSFL;
  SendHand(P);
  //SPITransfer(0xFF);
  while (count--) *destination++=SPITransfer(0xFF);
 SetCSFL;
}


*/



